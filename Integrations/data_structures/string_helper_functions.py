to do

Function 1: is_palindrome
This function checks whether a given string is a palindrome or not. A palindrome is a string that is the same forwards and backwards.

python
Copy code
def is_palindrome(s: str) -> bool:
    """
    Check if a given string is a palindrome.
    
    Time Complexity: O(n)
    Space Complexity: O(1)
    """
    start, end = 0, len(s) - 1
    while start < end:
        if s[start] != s[end]:
            return False
        start += 1
        end -= 1
    return True
The time complexity of this function is O(n), where n is the length of the input string. This is because we need to compare each character in the string once. The space complexity is O(1) because we are only using a fixed amount of memory for our variables start and end.

Function 2: longest_common_prefix
This function finds the longest common prefix of a list of strings. The prefix is the beginning of each string that is the same.

python
Copy code
def longest_common_prefix(strs: List[str]) -> str:
    """
    Find the longest common prefix of a list of strings.
    
    Time Complexity: O(nm)
    Space Complexity: O(1)
    """
    if not strs:
        return ""
    prefix = strs[0]
    for i in range(1, len(strs)):
        while strs[i].find(prefix) != 0:
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix
The time complexity of this function is O(nm), where n is the number of strings in the input list and m is the length of the shortest string. This is because we need to compare each character in each string, up to the length of the shortest string. The space complexity is O(1) because we are only using a fixed amount of memory for our variables prefix and i.

Function 3: reverse_string
This function reverses a given string.

python
Copy code
def reverse_string(s: List[str]) -> None:
    """
    Reverse a given string in-place.
    
    Time Complexity: O(n)
    Space Complexity: O(1)
    """
    start, end = 0, len(s) - 1
    while start < end:
        s[start], s[end] = s[end], s[start]
        start += 1
        end -= 1
The time complexity of this function is O(n), where n is the length of the input string. This is because we need to swap each pair of characters in the string once. The space complexity is O(1) because we are modifying the input string in place, so we are not using any additional memory.




Sarvesh Chandra
any more?
Yes, here are a few more helper functions for solving DSA string problems in Python:

Function 4: is_anagram
This function checks whether two strings are anagrams of each other. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase.

python
Copy code
def is_anagram(s: str, t: str) -> bool:
    """
    Check if two strings are anagrams of each other.
    
    Time Complexity: O(n)
    Space Complexity: O(1)
    """
    if len(s) != len(t):
        return False
    freq = [0] * 26
    for char in s:
        freq[ord(char) - ord('a')] += 1
    for char in t:
        freq[ord(char) - ord('a')] -= 1
        if freq[ord(char) - ord('a')] < 0:
            return False
    return True
The time complexity of this function is O(n), where n is the length of the input strings. This is because we need to iterate over each character in each string once. The space complexity is O(1) because we are using a fixed amount of memory for our variable freq, which is an array of size 26 (one for each letter of the alphabet).

Function 5: count_and_say
This function generates the nth term of the count-and-say sequence. The count-and-say sequence is a sequence of integers where each term is the description of the previous term.

python
Copy code
def count_and_say(n: int) -> str:
    """
    Generate the nth term of the count-and-say sequence.
    
    Time Complexity: O(n*2^n)
    Space Complexity: O(2^n)
    """
    if n == 1:
        return "1"
    prev_term = count_and_say(n-1)
    result = []
    count = 1
    for i in range(len(prev_term)):
        if i == len(prev_term) - 1 or prev_term[i] != prev_term[i+1]:
            result.append(str(count) + prev_term[i])
            count = 1
        else:
            count += 1
    return "".join(result)
The time complexity of this function is O(n2^n), where n is the input parameter. This is because each term in the count-and-say sequence is generated by iterating over the previous term and counting the number of consecutive digits. The length of the nth term is roughly 2^n, so we need to iterate over 2^n digits for each term. Therefore, the time complexity is roughly O(n2^n). The space complexity is also O(2^n) because we are using a list to store the result of each iteration, which could have up to 2^n digits.




Sarvesh Chandra
any more helpful?
Sure, here are a few more helper functions for solving DSA string problems in Python:

Function 6: longest_common_prefix
This function finds the longest common prefix string amongst an array of strings. A common prefix is a string that is common to all strings in the array.

python
Copy code
def longest_common_prefix(strs: List[str]) -> str:
    """
    Find the longest common prefix string amongst an array of strings.
    
    Time Complexity: O(n*m), where n is the length of the input array and m is the length of the shortest string
    Space Complexity: O(1)
    """
    if not strs:
        return ""
    prefix = strs[0]
    for i in range(1, len(strs)):
        while strs[i].find(prefix) != 0:
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix
The time complexity of this function is O(nm), where n is the length of the input array and m is the length of the shortest string in the array. This is because we iterate over each string in the array and compare each character of the prefix to the corresponding character in each string. The while loop runs at most m times for each string, so the overall time complexity is O(nm). The space complexity is O(1) because we are using a fixed amount of memory for our variable prefix, which is a string.

Function 7: is_palindrome
This function checks whether a given string is a palindrome. A palindrome is a string that reads the same backward as forward.

python
Copy code
def is_palindrome(s: str) -> bool:
    """
    Check whether a given string is a palindrome.
    
    Time Complexity: O(n)
    Space Complexity: O(1)
    """
    left, right = 0, len(s) - 1
    while left < right:
        while left < right and not s[left].isalnum():
            left += 1
        while left < right and not s[right].isalnum():
            right -= 1
        if s[left].lower() != s[right].lower():
            return False
        left += 1
        right -= 1
    return True
The time complexity of this function is O(n), where n is the length of the input string. This is because we iterate over each character in the string once. The space complexity is O(1) because we are using a fixed amount of memory for our variables left and right, which are integers.




Sarvesh Chandra
any more?
Sure, here are a few more helper functions for solving DSA string problems in Python:

Function 8: reverse_string
This function reverses a given string in place. That is, it modifies the input string instead of creating a new one.

python
Copy code
def reverse_string(s: List[str]) -> None:
    """
    Reverse a given string in place.
    
    Time Complexity: O(n)
    Space Complexity: O(1)
    """
    left, right = 0, len(s) - 1
    while left < right:
        s[left], s[right] = s[right], s[left]
        left += 1
        right -= 1
The time complexity of this function is O(n), where n is the length of the input string. This is because we iterate over each character in the string once. The space complexity is O(1) because we are modifying the input string in place, so we are not using any extra memory.

Function 9: reverse_words
This function reverses the order of words in a given string. A word is defined as a sequence of non-space characters.

python
Copy code
def reverse_words(s: str) -> str:
    """
    Reverse the order of words in a given string.
    
    Time Complexity: O(n)
    Space Complexity: O(n)
    """
    words = s.split()
    words.reverse()
    return " ".join(words)
The time complexity of this function is O(n), where n is the length of the input string. This is because we split the string into a list of words and then reverse the order of the words in the list, which takes O(n) time. The space complexity is also O(n) because we create a new list to store the words and a new string to join the reversed words together.

Function 10: find_all_anagrams
This function finds all the starting indices of the anagrams of a given pattern in a given string. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase.

python
Copy code
def find_all_anagrams(s: str, p: str) -> List[int]:
    """
    Find all the starting indices of the anagrams of a given pattern in a given string.
    
    Time Complexity: O(n)
    Space Complexity: O(1)
    """
    result = []
    if len(p) > len(s):
        return result
    freq_p = [0] * 26
    freq_s = [0] * 26
    for char in p:
        freq_p[ord(char) - ord('a')] += 1
    for i in range(len(p)):
        freq_s[ord(s[i]) - ord('a')] += 1
    if freq_p == freq_s:
        result.append(0)
    for i in range(len(p), len(s)):
        freq_s[ord(s[i]) - ord('a')] += 1
        freq_s[ord(s[i - len(p)]) - ord('a')] -= 1
        if freq_p == freq_s:
            result.append(i - len(p) + 1)
    return result
The time complexity of this function is O(n), where n is the length of the input string. This is because we iterate over each character in the string once. The space complexity is O(1) because we are using a fixed amount of memory for our variables freq_p and freq_s, which are arrays of size 26 (one for each letter of the alphabet).




Sarvesh Chandra
any more?
Sure, here are a few more helper functions for solving DSA string problems in Python:

Function 11: longest_common_prefix
This function returns the longest common prefix among a list of strings.

python
Copy code
def longest_common_prefix(strs: List[str]) -> str:
    """
    Return the longest common prefix among a list of strings.
    
    Time Complexity: O(n*m)
    Space Complexity: O(1)
    """
    if not strs:
        return ""
    prefix = strs[0]
    for i in range(1, len(strs)):
        while not strs[i].startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix
The time complexity of this function is O(n*m), where n is the number of strings in the input list and m is the length of the shortest string. This is because we iterate over each character in the shortest string n times. The space complexity is O(1) because we are using a fixed amount of memory for our variables prefix, which is a string.

Function 12: valid_palindrome
This function checks if a given string is a valid palindrome, meaning it reads the same backward as forward.

python
Copy code
def valid_palindrome(s: str) -> bool:
    """
    Check if a given string is a valid palindrome.
    
    Time Complexity: O(n)
    Space Complexity: O(1)
    """
    left, right = 0, len(s) - 1
    while left < right:
        while left < right and not s[left].isalnum():
            left += 1
        while left < right and not s[right].isalnum():
            right -= 1
        if s[left].lower() != s[right].lower():
            return False
        left += 1
        right -= 1
    return True
The time complexity of this function is O(n), where n is the length of the input string. This is because we iterate over each character in the string once. The space complexity is O(1) because we are not using any extra memory.

Function 13: group_anagrams
This function groups a list of strings into groups of anagrams.

python
Copy code
def group_anagrams(strs: List[str]) -> List[List[str]]:
    """
    Group a list of strings into groups of anagrams.
    
    Time Complexity: O(n*m*log(m))
    Space Complexity: O(n)
    """
    groups = {}
    for s in strs:
        key = tuple(sorted(s))
        groups.setdefault(key, [])
        groups[key].append(s)
    return list(groups.values())
The time complexity of this function is O(nmlog(m)), where n is the number of strings in the input list and m is the length of the longest string. This is because we sort each string once, which takes O(m*log(m)) time, and then we iterate over each string once. The space complexity is O(n) because we create a new list for each group of anagrams.




Sarvesh Chandra
any more?
Sure, here are a few more helper functions for solving DSA string problems in Python:

Function 14: reverse_string
This function reverses a string in place.

python
Copy code
def reverse_string(s: List[str]) -> None:
    """
    Reverse a string in place.
    
    Time Complexity: O(n)
    Space Complexity: O(1)
    """
    left, right = 0, len(s) - 1
    while left < right:
        s[left], s[right] = s[right], s[left]
        left += 1
        right -= 1
The time complexity of this function is O(n), where n is the length of the input string. This is because we iterate over each character in the string once, swapping the first and last characters, then the second and second-to-last characters, and so on until we reach the middle of the string. The space complexity is O(1) because we are swapping the characters in place without using any extra memory.

Function 15: isomorphic_strings
This function checks if two given strings are isomorphic, meaning the characters in one string can be replaced to get the other string.

python
Copy code
def isomorphic_strings(s: str, t: str) -> bool:
    """
    Check if two given strings are isomorphic.
    
    Time Complexity: O(n)
    Space Complexity: O(1)
    """
    if len(s) != len(t):
        return False
    s_to_t = {}
    t_to_s = {}
    for i in range(len(s)):
        if s[i] in s_to_t and s_to_t[s[i]] != t[i]:
            return False
        if t[i] in t_to_s and t_to_s[t[i]] != s[i]:
            return False
        s_to_t[s[i]] = t[i]
        t_to_s[t[i]] = s[i]
    return True
The time complexity of this function is O(n), where n is the length of the input strings. This is because we iterate over each character in the strings once, checking if each character in one string maps to the corresponding character in the other string. The space complexity is O(1) because we are using a fixed amount of memory for our variables s_to_t and t_to_s, which are dictionaries.

Function 16: count_and_say
This function generates the nth term in the "count and say" sequence.

python
Copy code
def count_and_say(n: int) -> str:
    """
    Generate the nth term in the "count and say" sequence.
    
    Time Complexity: O(2^n)
    Space Complexity: O(2^(n-1))
    """
    if n == 1:
        return "1"
    prev = count_and_say(n-1)
    result = ""
    count = 1
    for i in range(1, len(prev)):
        if prev[i] == prev[i-1]:
            count += 1
        else:
            result += str(count) + prev[i-1]
            count = 1
    result += str(count) + prev[-1]
    return result
The time complexity of this function is O(2^n), where n is the input number. This is because each term in the sequence is generated by reading the previous term aloud and counting the digits and repeating digits. The length of the nth term is roughly twice the length of the (n-1)th term, so the space complexity is O(2^(n-1)), which is the maximum size of the sequence that we need to store.




Sarvesh Chandra
any more?
Sure, here are a few more helper functions for solving DSA string problems in Python:

Function 17: longest_common_prefix
This function finds the longest common prefix among a list of strings.

python
Copy code
def longest_common_prefix(strs: List[str]) -> str:
    """
    Find the longest common prefix among a list of strings.
    
    Time Complexity: O(nm), where n is the number of strings and m is the length of the shortest string
    Space Complexity: O(1)
    """
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s) and prefix[i] == s[i]:
            i += 1
        prefix = prefix[:i]
        if not prefix:
            return ""
    return prefix
The time complexity of this function is O(nm), where n is the number of strings and m is the length of the shortest string. This is because we iterate over each character in the shortest string, checking if it is the same as the corresponding character in each of the other strings. The space complexity is O(1) because we are only using a fixed amount of memory for our variables.

Function 18: group_anagrams
This function groups anagrams together in a list of strings.

python
Copy code
def group_anagrams(strs: List[str]) -> List[List[str]]:
    """
    Group anagrams together in a list of strings.
    
    Time Complexity: O(nmlogm), where n is the number of strings and m is the length of the longest string
    Space Complexity: O(nm)
    """
    groups = {}
    for s in strs:
        sorted_s = "".join(sorted(s))
        if sorted_s not in groups:
            groups[sorted_s] = []
        groups[sorted_s].append(s)
    return list(groups.values())
The time complexity of this function is O(nmlogm), where n is the number of strings and m is the length of the longest string. This is because we need to sort each string to check if it is an anagram of another string, and sorting takes O(mlogm) time. The space complexity is O(nm) because we need to store each string and its sorted version in a dictionary.

Function 19: longest_palindrome
This function finds the longest palindrome in a string.

python
Copy code
def longest_palindrome(s: str) -> str:
    """
    Find the longest palindrome in a string.
    
    Time Complexity: O(n^2)
    Space Complexity: O(1)
    """
    if len(s) < 2:
        return s
    max_palindrome = ""
    for i in range(len(s)):
        # check odd-length palindromes
        left, right = i, i
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        if right - left - 1 > len(max_palindrome):
            max_palindrome = s[left+1:right]
        # check even-length palindromes
        left, right = i, i+1
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        if right - left - 1 > len(max_palindrome):
            max_palindrome = s[left+1:right]
    return max_palindrome
The time complexity of this function is O(n^2), where n is the length of the input string. This is because




Sarvesh Chandra
any more?
Here are a few more helper functions for solving DSA string problems in Python:

Function 20: compress_string
This function compresses a string by replacing consecutive repeated characters with the character followed by the count.

python
Copy code
def compress_string(s: str) -> str:
    """
    Compress a string by replacing consecutive repeated characters with the character followed by the count.
    
    Time Complexity: O(n)
    Space Complexity: O(n)
    """
    if not s:
        return ""
    compressed = []
    count = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            count += 1
        else:
            compressed.append(s[i-1] + str(count))
            count = 1
    compressed.append(s[-1] + str(count))
    compressed_str = "".join(compressed)
    return compressed_str if len(compressed_str) < len(s) else s
The time complexity of this function is O(n), where n is the length of the input string. We iterate over each character in the string once. The space complexity is also O(n), because we create a list of compressed characters.

Function 21: is_rotation
This function checks if one string is a rotation of another string.

python
Copy code
def is_rotation(s1: str, s2: str) -> bool:
    """
    Check if one string is a rotation of another string.
    
    Time Complexity: O(n), where n is the length of the input strings
    Space Complexity: O(n)
    """
    if len(s1) != len(s2):
        return False
    s2s2 = s2 + s2
    return s1 in s2s2
The time complexity of this function is O(n), where n is the length of the input strings. We create a new string by concatenating s2 with itself, which takes O(n) time. Then we check if s1 is a substring of the new string, which also takes O(n) time. The space complexity is also O(n), because we create a new string of length 2n.

Function 22: remove_duplicates
This function removes duplicate characters from a string.

python
Copy code
def remove_duplicates(s: str) -> str:
    """
    Remove duplicate characters from a string.
    
    Time Complexity: O(n)
    Space Complexity: O(n)
    """
    seen = set()
    new_s = []
    for c in s:
        if c not in seen:
            seen.add(c)
            new_s.append(c)
    return "".join(new_s)
The time complexity of this function is O(n), where n is the length of the input string. We iterate over each character in the string once, and checking if a character is in a set takes constant time on average. The space complexity is also O(n), because we create a new list of non-duplicate characters.



